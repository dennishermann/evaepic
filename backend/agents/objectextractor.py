# -*- coding: utf-8 -*-
"""ObjectExtractor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JU4Kl5plxELxBpkVO1DzoQOo3DHMkJTX
"""

# Order Object Extractor Agent
# Easy module for askLio Hackathon - runs in Google Colab
# Your job: Extract structured order data from messy user input

# ============================================================
# STEP 1: Install Dependencies
# ============================================================
!pip install langchain langchain-anthropic python-dotenv langchain_core --upgrade -q

# ============================================================
# STEP 2: Setup
# ============================================================
import os
import json
import logging # Added
from langchain_anthropic import ChatAnthropic
from langchain_core.prompts import ChatPromptTemplate # Changed import path
from langchain_core.output_parsers import PydanticOutputParser # Changed import path
from pydantic import BaseModel, Field
from typing import List, Optional # Optional added for export function

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') # Added

# Set your Anthropic API key
# Get it from: https://console.anthropic.com/
os.environ["ANTHROPIC_API_KEY"] = "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"  # REPLACE THIS

# ============================================================
# STEP 3: Define Order Structure (Pydantic Model)
# ============================================================
class QuantityRange(BaseModel):
    """Quantity details"""
    min: int = Field(description="Minimum quantity needed")
    max: int = Field(description="Maximum quantity willing to order")
    preferred: int = Field(description="Preferred/target quantity")

class Requirements(BaseModel):
    """Order requirements"""
    mandatory: List[str] = Field(description="Must-have requirements")
    optional: List[str] = Field(description="Nice-to-have requirements")

class OrderObject(BaseModel):
    """Structured order object extracted from user input"""
    item: str = Field(description="The product/item being ordered")
    quantity: QuantityRange = Field(description="Quantity range")
    budget: float = Field(description="Budget amount in numeric form")
    currency: str = Field(description="Currency code (USD, EUR, etc)")
    requirements: Requirements = Field(description="Mandatory and optional requirements")
    urgency: str = Field(description="Delivery urgency: low, medium, high, urgent")

# Validation function (added after Pydantic models are defined)
def validate_order(order: OrderObject) -> bool:
    """Validates the extracted order object."""
    if order.budget <= 0:
        logging.warning(f"Validation failed for order '{order.item}': Budget is non-positive ({order.budget})")
        return False
    if order.quantity.min <= 0:
        logging.warning(f"Validation failed for order '{order.item}': Minimum quantity is non-positive ({order.quantity.min})")
        return False
    if order.quantity.preferred <= 0: # Adding a check for preferred quantity too
        logging.warning(f"Validation failed for order '{order.item}': Preferred quantity is non-positive ({order.quantity.preferred})")
        return False
    return True

# ============================================================
# STEP 4: Create the Extraction Agent
# ============================================================
class OrderExtractorAgent:
    def __init__(self):
        # Initialize Claude
        self.llm = ChatAnthropic(
            model="claude-sonnet-4-20250514",
            temperature=0
        )

        # Setup output parser
        self.parser = PydanticOutputParser(pydantic_object=OrderObject)

        # Create prompt template
        self.prompt = ChatPromptTemplate.from_messages([
            ("system", """You are an expert at extracting structured order information from casual user input.

Extract the following information:
- Item: What product/service they want
- Quantity: Min/max/preferred amounts (if range given, calculate preferred as middle)
- Budget: Numeric amount
- Currency: Infer from context ($ = USD, â‚¬ = EUR, etc)
- Requirements: Separate mandatory vs optional needs
- Urgency: Infer from phrases like "ASAP", "fast", "no rush"

{format_instructions}

Be intelligent about:
- Ranges: "100-150" â†’ min:100, max:150, preferred:125
- Vague amounts: "around 100" â†’ min:90, max:110, preferred:100
- Budget: "4.5k" or "$4500" â†’ 4500
- Requirements: "need warranty" = mandatory, "would be nice to have warranty" = optional
"""),
            ("human", "{user_input}")
        ])

        # Create chain
        self.chain = self.prompt | self.llm | self.parser

    def extract(self, user_input: str) -> OrderObject:
        """Extract order object from user input"""
        result = self.chain.invoke({
            "user_input": user_input,
            "format_instructions": self.parser.get_format_instructions()
        })
        return result

# ============================================================
# STEP 5: Test the Agent
# ============================================================

# Initialize agent
agent = OrderExtractorAgent()

# Test cases
test_inputs = [
    "I need 100 Arduino boards, budget is $4500",

    "Hey can you get me like 50-75 Raspberry Pi units? Budget around 3k, need them ASAP with warranty",

    "Looking for industrial sensors, probably 200 units, maybe up to 250. Budget is â‚¬8000. Would be nice to have extended support but not required. No rush on delivery.",

    "Need office chairs urgently! Around 30 chairs, budget $6000, must have ergonomic design, optional would be wheels",
    "I need 10 widgets, but my budget is $0" # Added a test case for validation failure
]

# Run tests
print("=" * 60)
print("ORDER EXTRACTOR AGENT - TEST RESULTS")
print("=" * 60)

for i, test_input in enumerate(test_inputs, 1):
    print(f"\n{'='*60}")
    print(f"TEST {i}")
    print(f"{'='*60}")
    print(f"INPUT: {test_input}")
    print(f"\n{'OUTPUT:':-^60}")

    try:
        result = agent.extract(test_input)
        logging.info(f"Extracted (Test {i}): {result.item}") # Logging after extraction

        if not validate_order(result):
            print(f"âŒ VALIDATION FAILED for: {result.item}")
            print(json.dumps(result.model_dump(), indent=2)) # Still print to see what was extracted
            print(f"\n{'âŒ VALIDATION FAILED':-^60}")
        else:
            print(json.dumps(result.model_dump(), indent=2))
            print(f"\n{'âœ… SUCCESS':-^60}")
    except Exception as e:
        logging.error(f"Error processing test input '{test_input}': {e}") # Enhanced error logging
        print(f"âŒ ERROR: {e}")

    print()

# ============================================================
# STEP 6: Interactive Mode - Try Your Own Inputs
# ============================================================
print("\n" + "="*60)
print("INTERACTIVE MODE - Try your own inputs!")
print("="*60)
print("Type 'quit' to exit\n")

while True:
    user_input = input("Enter order request: ").strip()

    if user_input.lower() in ['quit', 'exit', 'q']:
        print("Goodbye!")
        break

    if not user_input:
        continue

    try:
        result = agent.extract(user_input)
        logging.info(f"Extracted (Interactive): {result.item}") # Logging after extraction

        if not validate_order(result):
            print(f"âŒ Validation failed for order: {result.item}. Please check input.")
            print(json.dumps(result.model_dump(), indent=2)) # Show the extracted invalid order
            print()
            continue # Ask for next input
        else:
            print("\nðŸ“¦ Extracted Order Object:")
            print(json.dumps(result.model_dump(), indent=2))
            print()
    except Exception as e:
        logging.error(f"Error processing interactive input '{user_input}': {e}") # Enhanced error logging
        print(f"âŒ Error: {e}\n")

# ============================================================
# STEP 7: Export Function for Your Teammates
# ============================================================
def extract_order(user_input: str) -> Optional[dict]: # Changed return type to Optional[dict]
    """
    Simple function your teammates can call.

    Args:
        user_input: Raw user text

    Returns:
        dict: Structured order object, or None if validation fails.

    Example:
        >>> order = extract_order("I need 100 Arduino boards, budget $4500")
        >>> print(order['item'])
        'Arduino boards'
    """
    agent = OrderExtractorAgent()
    result = agent.extract(user_input)
    logging.info(f"Extracted (export function): {result.item}") # Logging after extraction

    if not validate_order(result):
        logging.warning(f"Validation failed for order '{result.item}'. Returning None.")
        return None # Return None if validation fails

    return result.model_dump()

# Test the export function
print("\n" + "="*60)
print("EXPORT FUNCTION TEST")
print("="*60)
order = extract_order("Need 50 laptops, budget $25000, must have warranty")
print(json.dumps(order, indent=2) if order else "Validation failed, returned None")

order_invalid = extract_order("I need 5 items, budget $0") # Test invalid case
print("\n" + "="*60)
print("EXPORT FUNCTION INVALID TEST")
print("="*60)
print(json.dumps(order_invalid, indent=2) if order_invalid else "Validation failed, returned None")